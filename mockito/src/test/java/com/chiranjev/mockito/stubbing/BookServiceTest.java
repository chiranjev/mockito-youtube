package com.chiranjev.mockito.stubbing;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.time.LocalDate;
import java.util.ArrayList;
import java.util.List;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.*;

@ExtendWith(MockitoExtension.class)
public class BookServiceTest {
    @InjectMocks
    private BookService bookService;

    @Mock
    private BookRepository bookRepository;

    @Test
    public void testCalculateTotalCostOfBooks() {
        List<String> bookIds = new ArrayList();
        bookIds.add("1234");
        bookIds.add("1235");

        Book book1 = new Book("1234", "Mockito In Action", 250, LocalDate.now());
        Book book2 = new Book("1235", "JUnit 5 In Action", 200, LocalDate.now());

        /*

        // when(myService.doSomething()).thenReturn(10).thenReturn(20);
        // myService.doSomething()// returns 10
        // myService.doSomething()// returns 20
        // myService.doSomething()// returns 20

        // when(myService.doSomething()).thenReturn(10, 20);
        // myService.doSomething()// returns 10
        // myService.doSomething()// returns 20
        // myService.doSomething()// returns 20

        You can put as many arguments as you like in the brackets of thenReturn,
        provided they're all the correct type. The first value will be returned
        the first time the method is called, then the second answer, and so on.
        The last value will be returned repeatedly once all the other values are used up.

         */


        /*
        // Stubbing multiple calls to the same method

        when(bookRepository.findBookByBookId("1234")).thenReturn(book1,book2);
        // or
        when(bookRepository.findBookByBookId("1234"))
                .thenReturn(book1)
                .thenReturn(book2);
         */

        when(bookRepository.findBookByBookId("1234")).thenReturn(book1);
        when(bookRepository.findBookByBookId("1235")).thenReturn(book2);
//        doReturn(book1).when(bookRepository).findBookByBookId("1234");
//        doReturn(book2).when(bookRepository).findBookByBookId("1235");
        int actualCost = bookService.calculateTotalCost(bookIds);
        int expectedCost = 450;
        assertEquals(expectedCost, actualCost);
    }

    // Stubbing void methods

    @Test
    public void testSaveBook() {
        Book book1 = new Book(null, "Mockito In Action", 250, LocalDate.now());
        // we won't pass an id as usually when saving in real world database,
        // id is autogenerated by persistence frameworks or something else
        doNothing().when(bookRepository).save(book1); // it uses equals() method of Object class which uses == for comparison
        bookService.addBook(book1);

    }

    @Test
    public void testSaveBookWithBookRequest() {
       BookRequest bookRequest = new BookRequest("Mockito In Action", 250, LocalDate.now());
       Book book = new Book(null, "Mockito In Action", 250, LocalDate.now());
       doNothing().when(bookRepository).save(book); // it uses the equals() method of Book class as it is overridden.
       bookService.addBook(bookRequest);
    }

}
